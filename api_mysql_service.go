/*
API Управляемых сервисов

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.1.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package begetOpenapiCloud

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// MysqlServiceApiService MysqlServiceApi service
type MysqlServiceApiService service

type ApiMysqlServiceChangeAccessPasswordRequest struct {
	ctx context.Context
	ApiService *MysqlServiceApiService
	serviceId string
	dbName string
	host string
	mysqlChangeAccessPasswordRequest *MysqlChangeAccessPasswordRequest
}

func (r ApiMysqlServiceChangeAccessPasswordRequest) MysqlChangeAccessPasswordRequest(mysqlChangeAccessPasswordRequest MysqlChangeAccessPasswordRequest) ApiMysqlServiceChangeAccessPasswordRequest {
	r.mysqlChangeAccessPasswordRequest = &mysqlChangeAccessPasswordRequest
	return r
}

func (r ApiMysqlServiceChangeAccessPasswordRequest) Execute() (*MysqlChangeAccessPasswordResponse, *http.Response, error) {
	return r.ApiService.MysqlServiceChangeAccessPasswordExecute(r)
}

/*
MysqlServiceChangeAccessPassword Method for MysqlServiceChangeAccessPassword

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @param dbName
 @param host
 @return ApiMysqlServiceChangeAccessPasswordRequest
*/
func (a *MysqlServiceApiService) MysqlServiceChangeAccessPassword(ctx context.Context, serviceId string, dbName string, host string) ApiMysqlServiceChangeAccessPasswordRequest {
	return ApiMysqlServiceChangeAccessPasswordRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
		dbName: dbName,
		host: host,
	}
}

// Execute executes the request
//  @return MysqlChangeAccessPasswordResponse
func (a *MysqlServiceApiService) MysqlServiceChangeAccessPasswordExecute(r ApiMysqlServiceChangeAccessPasswordRequest) (*MysqlChangeAccessPasswordResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MysqlChangeAccessPasswordResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MysqlServiceApiService.MysqlServiceChangeAccessPassword")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/mysql/{service_id}/db/{db_name}/access/{host}"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"db_name"+"}", url.PathEscape(parameterToString(r.dbName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"host"+"}", url.PathEscape(parameterToString(r.host, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mysqlChangeAccessPasswordRequest == nil {
		return localVarReturnValue, nil, reportError("mysqlChangeAccessPasswordRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mysqlChangeAccessPasswordRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMysqlServiceCreateAccessRequest struct {
	ctx context.Context
	ApiService *MysqlServiceApiService
	serviceId string
	dbName string
	mysqlCreateAccessRequest *MysqlCreateAccessRequest
}

func (r ApiMysqlServiceCreateAccessRequest) MysqlCreateAccessRequest(mysqlCreateAccessRequest MysqlCreateAccessRequest) ApiMysqlServiceCreateAccessRequest {
	r.mysqlCreateAccessRequest = &mysqlCreateAccessRequest
	return r
}

func (r ApiMysqlServiceCreateAccessRequest) Execute() (*MysqlCreateAccessResponse, *http.Response, error) {
	return r.ApiService.MysqlServiceCreateAccessExecute(r)
}

/*
MysqlServiceCreateAccess Method for MysqlServiceCreateAccess

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @param dbName
 @return ApiMysqlServiceCreateAccessRequest
*/
func (a *MysqlServiceApiService) MysqlServiceCreateAccess(ctx context.Context, serviceId string, dbName string) ApiMysqlServiceCreateAccessRequest {
	return ApiMysqlServiceCreateAccessRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
		dbName: dbName,
	}
}

// Execute executes the request
//  @return MysqlCreateAccessResponse
func (a *MysqlServiceApiService) MysqlServiceCreateAccessExecute(r ApiMysqlServiceCreateAccessRequest) (*MysqlCreateAccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MysqlCreateAccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MysqlServiceApiService.MysqlServiceCreateAccess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/mysql/{service_id}/db/{db_name}/access"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"db_name"+"}", url.PathEscape(parameterToString(r.dbName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mysqlCreateAccessRequest == nil {
		return localVarReturnValue, nil, reportError("mysqlCreateAccessRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mysqlCreateAccessRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMysqlServiceCreateDbRequest struct {
	ctx context.Context
	ApiService *MysqlServiceApiService
	serviceId string
	mysqlCreateDbRequest *MysqlCreateDbRequest
}

func (r ApiMysqlServiceCreateDbRequest) MysqlCreateDbRequest(mysqlCreateDbRequest MysqlCreateDbRequest) ApiMysqlServiceCreateDbRequest {
	r.mysqlCreateDbRequest = &mysqlCreateDbRequest
	return r
}

func (r ApiMysqlServiceCreateDbRequest) Execute() (*MysqlCreateDbResponse, *http.Response, error) {
	return r.ApiService.MysqlServiceCreateDbExecute(r)
}

/*
MysqlServiceCreateDb Method for MysqlServiceCreateDb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiMysqlServiceCreateDbRequest
*/
func (a *MysqlServiceApiService) MysqlServiceCreateDb(ctx context.Context, serviceId string) ApiMysqlServiceCreateDbRequest {
	return ApiMysqlServiceCreateDbRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return MysqlCreateDbResponse
func (a *MysqlServiceApiService) MysqlServiceCreateDbExecute(r ApiMysqlServiceCreateDbRequest) (*MysqlCreateDbResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MysqlCreateDbResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MysqlServiceApiService.MysqlServiceCreateDb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/mysql/{service_id}/db"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mysqlCreateDbRequest == nil {
		return localVarReturnValue, nil, reportError("mysqlCreateDbRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mysqlCreateDbRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMysqlServiceGetConfigRequest struct {
	ctx context.Context
	ApiService *MysqlServiceApiService
	serviceId string
}

func (r ApiMysqlServiceGetConfigRequest) Execute() (*MysqlGetConfigResponse, *http.Response, error) {
	return r.ApiService.MysqlServiceGetConfigExecute(r)
}

/*
MysqlServiceGetConfig Method for MysqlServiceGetConfig

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiMysqlServiceGetConfigRequest
*/
func (a *MysqlServiceApiService) MysqlServiceGetConfig(ctx context.Context, serviceId string) ApiMysqlServiceGetConfigRequest {
	return ApiMysqlServiceGetConfigRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return MysqlGetConfigResponse
func (a *MysqlServiceApiService) MysqlServiceGetConfigExecute(r ApiMysqlServiceGetConfigRequest) (*MysqlGetConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MysqlGetConfigResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MysqlServiceApiService.MysqlServiceGetConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/mysql/{service_id}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMysqlServiceGetDbListRequest struct {
	ctx context.Context
	ApiService *MysqlServiceApiService
	serviceId string
}

func (r ApiMysqlServiceGetDbListRequest) Execute() (*MysqlGetDbListResponse, *http.Response, error) {
	return r.ApiService.MysqlServiceGetDbListExecute(r)
}

/*
MysqlServiceGetDbList Method for MysqlServiceGetDbList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiMysqlServiceGetDbListRequest
*/
func (a *MysqlServiceApiService) MysqlServiceGetDbList(ctx context.Context, serviceId string) ApiMysqlServiceGetDbListRequest {
	return ApiMysqlServiceGetDbListRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return MysqlGetDbListResponse
func (a *MysqlServiceApiService) MysqlServiceGetDbListExecute(r ApiMysqlServiceGetDbListRequest) (*MysqlGetDbListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MysqlGetDbListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MysqlServiceApiService.MysqlServiceGetDbList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/mysql/{service_id}/db"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMysqlServiceRemoveAccessRequest struct {
	ctx context.Context
	ApiService *MysqlServiceApiService
	serviceId string
	dbName string
	host string
}

func (r ApiMysqlServiceRemoveAccessRequest) Execute() (*MysqlRemoveAccessResponse, *http.Response, error) {
	return r.ApiService.MysqlServiceRemoveAccessExecute(r)
}

/*
MysqlServiceRemoveAccess Method for MysqlServiceRemoveAccess

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @param dbName
 @param host
 @return ApiMysqlServiceRemoveAccessRequest
*/
func (a *MysqlServiceApiService) MysqlServiceRemoveAccess(ctx context.Context, serviceId string, dbName string, host string) ApiMysqlServiceRemoveAccessRequest {
	return ApiMysqlServiceRemoveAccessRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
		dbName: dbName,
		host: host,
	}
}

// Execute executes the request
//  @return MysqlRemoveAccessResponse
func (a *MysqlServiceApiService) MysqlServiceRemoveAccessExecute(r ApiMysqlServiceRemoveAccessRequest) (*MysqlRemoveAccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MysqlRemoveAccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MysqlServiceApiService.MysqlServiceRemoveAccess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/mysql/{service_id}/db/{db_name}/access/{host}"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"db_name"+"}", url.PathEscape(parameterToString(r.dbName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"host"+"}", url.PathEscape(parameterToString(r.host, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMysqlServiceRemoveDbRequest struct {
	ctx context.Context
	ApiService *MysqlServiceApiService
	serviceId string
	dbName string
}

func (r ApiMysqlServiceRemoveDbRequest) Execute() (*MysqlRemoveDbResponse, *http.Response, error) {
	return r.ApiService.MysqlServiceRemoveDbExecute(r)
}

/*
MysqlServiceRemoveDb Method for MysqlServiceRemoveDb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @param dbName
 @return ApiMysqlServiceRemoveDbRequest
*/
func (a *MysqlServiceApiService) MysqlServiceRemoveDb(ctx context.Context, serviceId string, dbName string) ApiMysqlServiceRemoveDbRequest {
	return ApiMysqlServiceRemoveDbRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
		dbName: dbName,
	}
}

// Execute executes the request
//  @return MysqlRemoveDbResponse
func (a *MysqlServiceApiService) MysqlServiceRemoveDbExecute(r ApiMysqlServiceRemoveDbRequest) (*MysqlRemoveDbResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MysqlRemoveDbResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MysqlServiceApiService.MysqlServiceRemoveDb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/mysql/{service_id}/db/{db_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"db_name"+"}", url.PathEscape(parameterToString(r.dbName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMysqlServiceSetConfigRequest struct {
	ctx context.Context
	ApiService *MysqlServiceApiService
	serviceId string
	mysqlSetConfigRequest *MysqlSetConfigRequest
}

func (r ApiMysqlServiceSetConfigRequest) MysqlSetConfigRequest(mysqlSetConfigRequest MysqlSetConfigRequest) ApiMysqlServiceSetConfigRequest {
	r.mysqlSetConfigRequest = &mysqlSetConfigRequest
	return r
}

func (r ApiMysqlServiceSetConfigRequest) Execute() (*MysqlSetConfigResponse, *http.Response, error) {
	return r.ApiService.MysqlServiceSetConfigExecute(r)
}

/*
MysqlServiceSetConfig Method for MysqlServiceSetConfig

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiMysqlServiceSetConfigRequest
*/
func (a *MysqlServiceApiService) MysqlServiceSetConfig(ctx context.Context, serviceId string) ApiMysqlServiceSetConfigRequest {
	return ApiMysqlServiceSetConfigRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return MysqlSetConfigResponse
func (a *MysqlServiceApiService) MysqlServiceSetConfigExecute(r ApiMysqlServiceSetConfigRequest) (*MysqlSetConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MysqlSetConfigResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MysqlServiceApiService.MysqlServiceSetConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/mysql/{service_id}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mysqlSetConfigRequest == nil {
		return localVarReturnValue, nil, reportError("mysqlSetConfigRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mysqlSetConfigRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMysqlServiceUpdateDbRequest struct {
	ctx context.Context
	ApiService *MysqlServiceApiService
	serviceId string
	dbName string
	mysqlUpdateDbRequest *MysqlUpdateDbRequest
}

func (r ApiMysqlServiceUpdateDbRequest) MysqlUpdateDbRequest(mysqlUpdateDbRequest MysqlUpdateDbRequest) ApiMysqlServiceUpdateDbRequest {
	r.mysqlUpdateDbRequest = &mysqlUpdateDbRequest
	return r
}

func (r ApiMysqlServiceUpdateDbRequest) Execute() (*MysqlUpdateDbResponse, *http.Response, error) {
	return r.ApiService.MysqlServiceUpdateDbExecute(r)
}

/*
MysqlServiceUpdateDb Method for MysqlServiceUpdateDb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @param dbName
 @return ApiMysqlServiceUpdateDbRequest
*/
func (a *MysqlServiceApiService) MysqlServiceUpdateDb(ctx context.Context, serviceId string, dbName string) ApiMysqlServiceUpdateDbRequest {
	return ApiMysqlServiceUpdateDbRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
		dbName: dbName,
	}
}

// Execute executes the request
//  @return MysqlUpdateDbResponse
func (a *MysqlServiceApiService) MysqlServiceUpdateDbExecute(r ApiMysqlServiceUpdateDbRequest) (*MysqlUpdateDbResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MysqlUpdateDbResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MysqlServiceApiService.MysqlServiceUpdateDb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/mysql/{service_id}/db/{db_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"db_name"+"}", url.PathEscape(parameterToString(r.dbName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mysqlUpdateDbRequest == nil {
		return localVarReturnValue, nil, reportError("mysqlUpdateDbRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mysqlUpdateDbRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
