/*
API Управляемых сервисов

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package begetOpenapiCloud

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// MysqlStatisticServiceApiService MysqlStatisticServiceApi service
type MysqlStatisticServiceApiService service

type ApiMysqlStatisticServiceGetCpuRequest struct {
	ctx context.Context
	ApiService *MysqlStatisticServiceApiService
	serviceId string
	period *string
}

func (r ApiMysqlStatisticServiceGetCpuRequest) Period(period string) ApiMysqlStatisticServiceGetCpuRequest {
	r.period = &period
	return r
}

func (r ApiMysqlStatisticServiceGetCpuRequest) Execute() (*MysqlStatisticGetCpuResponse, *http.Response, error) {
	return r.ApiService.MysqlStatisticServiceGetCpuExecute(r)
}

/*
MysqlStatisticServiceGetCpu Method for MysqlStatisticServiceGetCpu

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiMysqlStatisticServiceGetCpuRequest
*/
func (a *MysqlStatisticServiceApiService) MysqlStatisticServiceGetCpu(ctx context.Context, serviceId string) ApiMysqlStatisticServiceGetCpuRequest {
	return ApiMysqlStatisticServiceGetCpuRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return MysqlStatisticGetCpuResponse
func (a *MysqlStatisticServiceApiService) MysqlStatisticServiceGetCpuExecute(r ApiMysqlStatisticServiceGetCpuRequest) (*MysqlStatisticGetCpuResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MysqlStatisticGetCpuResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MysqlStatisticServiceApiService.MysqlStatisticServiceGetCpu")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/mysql/{service_id}/statistic/cpu"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.period != nil {
		localVarQueryParams.Add("period", parameterToString(*r.period, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMysqlStatisticServiceGetCpuDetailsRequest struct {
	ctx context.Context
	ApiService *MysqlStatisticServiceApiService
	serviceId string
	period *string
}

func (r ApiMysqlStatisticServiceGetCpuDetailsRequest) Period(period string) ApiMysqlStatisticServiceGetCpuDetailsRequest {
	r.period = &period
	return r
}

func (r ApiMysqlStatisticServiceGetCpuDetailsRequest) Execute() (*MysqlStatisticGetCpuDetailsResponse, *http.Response, error) {
	return r.ApiService.MysqlStatisticServiceGetCpuDetailsExecute(r)
}

/*
MysqlStatisticServiceGetCpuDetails Method for MysqlStatisticServiceGetCpuDetails

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiMysqlStatisticServiceGetCpuDetailsRequest
*/
func (a *MysqlStatisticServiceApiService) MysqlStatisticServiceGetCpuDetails(ctx context.Context, serviceId string) ApiMysqlStatisticServiceGetCpuDetailsRequest {
	return ApiMysqlStatisticServiceGetCpuDetailsRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return MysqlStatisticGetCpuDetailsResponse
func (a *MysqlStatisticServiceApiService) MysqlStatisticServiceGetCpuDetailsExecute(r ApiMysqlStatisticServiceGetCpuDetailsRequest) (*MysqlStatisticGetCpuDetailsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MysqlStatisticGetCpuDetailsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MysqlStatisticServiceApiService.MysqlStatisticServiceGetCpuDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/mysql/{service_id}/statistic/cpu-details"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.period != nil {
		localVarQueryParams.Add("period", parameterToString(*r.period, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMysqlStatisticServiceGetDiskRequest struct {
	ctx context.Context
	ApiService *MysqlStatisticServiceApiService
	serviceId string
	period *string
}

func (r ApiMysqlStatisticServiceGetDiskRequest) Period(period string) ApiMysqlStatisticServiceGetDiskRequest {
	r.period = &period
	return r
}

func (r ApiMysqlStatisticServiceGetDiskRequest) Execute() (*MysqlStatisticGetDiskResponse, *http.Response, error) {
	return r.ApiService.MysqlStatisticServiceGetDiskExecute(r)
}

/*
MysqlStatisticServiceGetDisk Method for MysqlStatisticServiceGetDisk

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiMysqlStatisticServiceGetDiskRequest
*/
func (a *MysqlStatisticServiceApiService) MysqlStatisticServiceGetDisk(ctx context.Context, serviceId string) ApiMysqlStatisticServiceGetDiskRequest {
	return ApiMysqlStatisticServiceGetDiskRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return MysqlStatisticGetDiskResponse
func (a *MysqlStatisticServiceApiService) MysqlStatisticServiceGetDiskExecute(r ApiMysqlStatisticServiceGetDiskRequest) (*MysqlStatisticGetDiskResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MysqlStatisticGetDiskResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MysqlStatisticServiceApiService.MysqlStatisticServiceGetDisk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/mysql/{service_id}/statistic/disk"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.period != nil {
		localVarQueryParams.Add("period", parameterToString(*r.period, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMysqlStatisticServiceGetDiskUsageRequest struct {
	ctx context.Context
	ApiService *MysqlStatisticServiceApiService
	serviceId string
	period *string
}

func (r ApiMysqlStatisticServiceGetDiskUsageRequest) Period(period string) ApiMysqlStatisticServiceGetDiskUsageRequest {
	r.period = &period
	return r
}

func (r ApiMysqlStatisticServiceGetDiskUsageRequest) Execute() (*MysqlStatisticGetDiskUsageResponse, *http.Response, error) {
	return r.ApiService.MysqlStatisticServiceGetDiskUsageExecute(r)
}

/*
MysqlStatisticServiceGetDiskUsage Method for MysqlStatisticServiceGetDiskUsage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiMysqlStatisticServiceGetDiskUsageRequest
*/
func (a *MysqlStatisticServiceApiService) MysqlStatisticServiceGetDiskUsage(ctx context.Context, serviceId string) ApiMysqlStatisticServiceGetDiskUsageRequest {
	return ApiMysqlStatisticServiceGetDiskUsageRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return MysqlStatisticGetDiskUsageResponse
func (a *MysqlStatisticServiceApiService) MysqlStatisticServiceGetDiskUsageExecute(r ApiMysqlStatisticServiceGetDiskUsageRequest) (*MysqlStatisticGetDiskUsageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MysqlStatisticGetDiskUsageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MysqlStatisticServiceApiService.MysqlStatisticServiceGetDiskUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/mysql/{service_id}/statistic/disk-usage"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.period != nil {
		localVarQueryParams.Add("period", parameterToString(*r.period, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMysqlStatisticServiceGetLoadAverageRequest struct {
	ctx context.Context
	ApiService *MysqlStatisticServiceApiService
	serviceId string
	period *string
}

func (r ApiMysqlStatisticServiceGetLoadAverageRequest) Period(period string) ApiMysqlStatisticServiceGetLoadAverageRequest {
	r.period = &period
	return r
}

func (r ApiMysqlStatisticServiceGetLoadAverageRequest) Execute() (*MysqlStatisticGetLoadAverageResponse, *http.Response, error) {
	return r.ApiService.MysqlStatisticServiceGetLoadAverageExecute(r)
}

/*
MysqlStatisticServiceGetLoadAverage Method for MysqlStatisticServiceGetLoadAverage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiMysqlStatisticServiceGetLoadAverageRequest
*/
func (a *MysqlStatisticServiceApiService) MysqlStatisticServiceGetLoadAverage(ctx context.Context, serviceId string) ApiMysqlStatisticServiceGetLoadAverageRequest {
	return ApiMysqlStatisticServiceGetLoadAverageRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return MysqlStatisticGetLoadAverageResponse
func (a *MysqlStatisticServiceApiService) MysqlStatisticServiceGetLoadAverageExecute(r ApiMysqlStatisticServiceGetLoadAverageRequest) (*MysqlStatisticGetLoadAverageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MysqlStatisticGetLoadAverageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MysqlStatisticServiceApiService.MysqlStatisticServiceGetLoadAverage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/mysql/{service_id}/statistic/load-average"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.period != nil {
		localVarQueryParams.Add("period", parameterToString(*r.period, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMysqlStatisticServiceGetMemoryRequest struct {
	ctx context.Context
	ApiService *MysqlStatisticServiceApiService
	serviceId string
	period *string
}

func (r ApiMysqlStatisticServiceGetMemoryRequest) Period(period string) ApiMysqlStatisticServiceGetMemoryRequest {
	r.period = &period
	return r
}

func (r ApiMysqlStatisticServiceGetMemoryRequest) Execute() (*MysqlStatisticGetMemoryResponse, *http.Response, error) {
	return r.ApiService.MysqlStatisticServiceGetMemoryExecute(r)
}

/*
MysqlStatisticServiceGetMemory Method for MysqlStatisticServiceGetMemory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiMysqlStatisticServiceGetMemoryRequest
*/
func (a *MysqlStatisticServiceApiService) MysqlStatisticServiceGetMemory(ctx context.Context, serviceId string) ApiMysqlStatisticServiceGetMemoryRequest {
	return ApiMysqlStatisticServiceGetMemoryRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return MysqlStatisticGetMemoryResponse
func (a *MysqlStatisticServiceApiService) MysqlStatisticServiceGetMemoryExecute(r ApiMysqlStatisticServiceGetMemoryRequest) (*MysqlStatisticGetMemoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MysqlStatisticGetMemoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MysqlStatisticServiceApiService.MysqlStatisticServiceGetMemory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/mysql/{service_id}/statistic/memory"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.period != nil {
		localVarQueryParams.Add("period", parameterToString(*r.period, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMysqlStatisticServiceGetNetworkRequest struct {
	ctx context.Context
	ApiService *MysqlStatisticServiceApiService
	serviceId string
	period *string
}

func (r ApiMysqlStatisticServiceGetNetworkRequest) Period(period string) ApiMysqlStatisticServiceGetNetworkRequest {
	r.period = &period
	return r
}

func (r ApiMysqlStatisticServiceGetNetworkRequest) Execute() (*MysqlStatisticGetNetworkResponse, *http.Response, error) {
	return r.ApiService.MysqlStatisticServiceGetNetworkExecute(r)
}

/*
MysqlStatisticServiceGetNetwork Method for MysqlStatisticServiceGetNetwork

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiMysqlStatisticServiceGetNetworkRequest
*/
func (a *MysqlStatisticServiceApiService) MysqlStatisticServiceGetNetwork(ctx context.Context, serviceId string) ApiMysqlStatisticServiceGetNetworkRequest {
	return ApiMysqlStatisticServiceGetNetworkRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return MysqlStatisticGetNetworkResponse
func (a *MysqlStatisticServiceApiService) MysqlStatisticServiceGetNetworkExecute(r ApiMysqlStatisticServiceGetNetworkRequest) (*MysqlStatisticGetNetworkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MysqlStatisticGetNetworkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MysqlStatisticServiceApiService.MysqlStatisticServiceGetNetwork")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/mysql/{service_id}/statistic/network"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.period != nil {
		localVarQueryParams.Add("period", parameterToString(*r.period, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
