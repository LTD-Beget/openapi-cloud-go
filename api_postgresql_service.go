/*
API Управляемых сервисов

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.3.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package begetOpenapiCloud

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// PostgresqlServiceApiService PostgresqlServiceApi service
type PostgresqlServiceApiService service

type ApiPostgresqlServiceCreateDbRequest struct {
	ctx context.Context
	ApiService *PostgresqlServiceApiService
	serviceId string
	postgresqlPgCreateDbRequest *PostgresqlPgCreateDbRequest
}

func (r ApiPostgresqlServiceCreateDbRequest) PostgresqlPgCreateDbRequest(postgresqlPgCreateDbRequest PostgresqlPgCreateDbRequest) ApiPostgresqlServiceCreateDbRequest {
	r.postgresqlPgCreateDbRequest = &postgresqlPgCreateDbRequest
	return r
}

func (r ApiPostgresqlServiceCreateDbRequest) Execute() (*PostgresqlPgCreateDbResponse, *http.Response, error) {
	return r.ApiService.PostgresqlServiceCreateDbExecute(r)
}

/*
PostgresqlServiceCreateDb Method for PostgresqlServiceCreateDb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiPostgresqlServiceCreateDbRequest
*/
func (a *PostgresqlServiceApiService) PostgresqlServiceCreateDb(ctx context.Context, serviceId string) ApiPostgresqlServiceCreateDbRequest {
	return ApiPostgresqlServiceCreateDbRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return PostgresqlPgCreateDbResponse
func (a *PostgresqlServiceApiService) PostgresqlServiceCreateDbExecute(r ApiPostgresqlServiceCreateDbRequest) (*PostgresqlPgCreateDbResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostgresqlPgCreateDbResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostgresqlServiceApiService.PostgresqlServiceCreateDb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/postgresql/{service_id}/db"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postgresqlPgCreateDbRequest == nil {
		return localVarReturnValue, nil, reportError("postgresqlPgCreateDbRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postgresqlPgCreateDbRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostgresqlServiceCreateRoleRequest struct {
	ctx context.Context
	ApiService *PostgresqlServiceApiService
	serviceId string
	postgresqlPgCreateRoleRequest *PostgresqlPgCreateRoleRequest
}

func (r ApiPostgresqlServiceCreateRoleRequest) PostgresqlPgCreateRoleRequest(postgresqlPgCreateRoleRequest PostgresqlPgCreateRoleRequest) ApiPostgresqlServiceCreateRoleRequest {
	r.postgresqlPgCreateRoleRequest = &postgresqlPgCreateRoleRequest
	return r
}

func (r ApiPostgresqlServiceCreateRoleRequest) Execute() (*PostgresqlPgCreateRoleResponse, *http.Response, error) {
	return r.ApiService.PostgresqlServiceCreateRoleExecute(r)
}

/*
PostgresqlServiceCreateRole Method for PostgresqlServiceCreateRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiPostgresqlServiceCreateRoleRequest
*/
func (a *PostgresqlServiceApiService) PostgresqlServiceCreateRole(ctx context.Context, serviceId string) ApiPostgresqlServiceCreateRoleRequest {
	return ApiPostgresqlServiceCreateRoleRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return PostgresqlPgCreateRoleResponse
func (a *PostgresqlServiceApiService) PostgresqlServiceCreateRoleExecute(r ApiPostgresqlServiceCreateRoleRequest) (*PostgresqlPgCreateRoleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostgresqlPgCreateRoleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostgresqlServiceApiService.PostgresqlServiceCreateRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/postgresql/{service_id}/role"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postgresqlPgCreateRoleRequest == nil {
		return localVarReturnValue, nil, reportError("postgresqlPgCreateRoleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postgresqlPgCreateRoleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostgresqlServiceGetConfigRequest struct {
	ctx context.Context
	ApiService *PostgresqlServiceApiService
	serviceId string
}

func (r ApiPostgresqlServiceGetConfigRequest) Execute() (*PostgresqlPgGetConfigResponse, *http.Response, error) {
	return r.ApiService.PostgresqlServiceGetConfigExecute(r)
}

/*
PostgresqlServiceGetConfig Method for PostgresqlServiceGetConfig

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiPostgresqlServiceGetConfigRequest
*/
func (a *PostgresqlServiceApiService) PostgresqlServiceGetConfig(ctx context.Context, serviceId string) ApiPostgresqlServiceGetConfigRequest {
	return ApiPostgresqlServiceGetConfigRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return PostgresqlPgGetConfigResponse
func (a *PostgresqlServiceApiService) PostgresqlServiceGetConfigExecute(r ApiPostgresqlServiceGetConfigRequest) (*PostgresqlPgGetConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostgresqlPgGetConfigResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostgresqlServiceApiService.PostgresqlServiceGetConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/postgresql/{service_id}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostgresqlServiceGetDbListRequest struct {
	ctx context.Context
	ApiService *PostgresqlServiceApiService
	serviceId string
}

func (r ApiPostgresqlServiceGetDbListRequest) Execute() (*PostgresqlPgGetDbListResponse, *http.Response, error) {
	return r.ApiService.PostgresqlServiceGetDbListExecute(r)
}

/*
PostgresqlServiceGetDbList Method for PostgresqlServiceGetDbList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiPostgresqlServiceGetDbListRequest
*/
func (a *PostgresqlServiceApiService) PostgresqlServiceGetDbList(ctx context.Context, serviceId string) ApiPostgresqlServiceGetDbListRequest {
	return ApiPostgresqlServiceGetDbListRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return PostgresqlPgGetDbListResponse
func (a *PostgresqlServiceApiService) PostgresqlServiceGetDbListExecute(r ApiPostgresqlServiceGetDbListRequest) (*PostgresqlPgGetDbListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostgresqlPgGetDbListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostgresqlServiceApiService.PostgresqlServiceGetDbList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/postgresql/{service_id}/db"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostgresqlServiceGetRemoteAccessRequest struct {
	ctx context.Context
	ApiService *PostgresqlServiceApiService
	serviceId string
}

func (r ApiPostgresqlServiceGetRemoteAccessRequest) Execute() (*PostgresqlPgGetRemoteAccessResponse, *http.Response, error) {
	return r.ApiService.PostgresqlServiceGetRemoteAccessExecute(r)
}

/*
PostgresqlServiceGetRemoteAccess Method for PostgresqlServiceGetRemoteAccess

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiPostgresqlServiceGetRemoteAccessRequest
*/
func (a *PostgresqlServiceApiService) PostgresqlServiceGetRemoteAccess(ctx context.Context, serviceId string) ApiPostgresqlServiceGetRemoteAccessRequest {
	return ApiPostgresqlServiceGetRemoteAccessRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return PostgresqlPgGetRemoteAccessResponse
func (a *PostgresqlServiceApiService) PostgresqlServiceGetRemoteAccessExecute(r ApiPostgresqlServiceGetRemoteAccessRequest) (*PostgresqlPgGetRemoteAccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostgresqlPgGetRemoteAccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostgresqlServiceApiService.PostgresqlServiceGetRemoteAccess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/postgresql/{service_id}/remote-access"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostgresqlServiceGetRoleListRequest struct {
	ctx context.Context
	ApiService *PostgresqlServiceApiService
	serviceId string
}

func (r ApiPostgresqlServiceGetRoleListRequest) Execute() (*PostgresqlPgGetRoleListResponse, *http.Response, error) {
	return r.ApiService.PostgresqlServiceGetRoleListExecute(r)
}

/*
PostgresqlServiceGetRoleList Method for PostgresqlServiceGetRoleList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiPostgresqlServiceGetRoleListRequest
*/
func (a *PostgresqlServiceApiService) PostgresqlServiceGetRoleList(ctx context.Context, serviceId string) ApiPostgresqlServiceGetRoleListRequest {
	return ApiPostgresqlServiceGetRoleListRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return PostgresqlPgGetRoleListResponse
func (a *PostgresqlServiceApiService) PostgresqlServiceGetRoleListExecute(r ApiPostgresqlServiceGetRoleListRequest) (*PostgresqlPgGetRoleListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostgresqlPgGetRoleListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostgresqlServiceApiService.PostgresqlServiceGetRoleList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/postgresql/{service_id}/role"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostgresqlServiceRemoveDbRequest struct {
	ctx context.Context
	ApiService *PostgresqlServiceApiService
	serviceId string
	dbName string
}

func (r ApiPostgresqlServiceRemoveDbRequest) Execute() (*PostgresqlPgRemoveDbResponse, *http.Response, error) {
	return r.ApiService.PostgresqlServiceRemoveDbExecute(r)
}

/*
PostgresqlServiceRemoveDb Method for PostgresqlServiceRemoveDb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @param dbName
 @return ApiPostgresqlServiceRemoveDbRequest
*/
func (a *PostgresqlServiceApiService) PostgresqlServiceRemoveDb(ctx context.Context, serviceId string, dbName string) ApiPostgresqlServiceRemoveDbRequest {
	return ApiPostgresqlServiceRemoveDbRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
		dbName: dbName,
	}
}

// Execute executes the request
//  @return PostgresqlPgRemoveDbResponse
func (a *PostgresqlServiceApiService) PostgresqlServiceRemoveDbExecute(r ApiPostgresqlServiceRemoveDbRequest) (*PostgresqlPgRemoveDbResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostgresqlPgRemoveDbResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostgresqlServiceApiService.PostgresqlServiceRemoveDb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/postgresql/{service_id}/db/{db_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"db_name"+"}", url.PathEscape(parameterToString(r.dbName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostgresqlServiceRemoveRoleRequest struct {
	ctx context.Context
	ApiService *PostgresqlServiceApiService
	serviceId string
	roleName string
}

func (r ApiPostgresqlServiceRemoveRoleRequest) Execute() (*PostgresqlPgRemoveRoleResponse, *http.Response, error) {
	return r.ApiService.PostgresqlServiceRemoveRoleExecute(r)
}

/*
PostgresqlServiceRemoveRole Method for PostgresqlServiceRemoveRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @param roleName
 @return ApiPostgresqlServiceRemoveRoleRequest
*/
func (a *PostgresqlServiceApiService) PostgresqlServiceRemoveRole(ctx context.Context, serviceId string, roleName string) ApiPostgresqlServiceRemoveRoleRequest {
	return ApiPostgresqlServiceRemoveRoleRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return PostgresqlPgRemoveRoleResponse
func (a *PostgresqlServiceApiService) PostgresqlServiceRemoveRoleExecute(r ApiPostgresqlServiceRemoveRoleRequest) (*PostgresqlPgRemoveRoleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostgresqlPgRemoveRoleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostgresqlServiceApiService.PostgresqlServiceRemoveRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/postgresql/{service_id}/role/{role_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role_name"+"}", url.PathEscape(parameterToString(r.roleName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostgresqlServiceSetConfigRequest struct {
	ctx context.Context
	ApiService *PostgresqlServiceApiService
	serviceId string
	postgresqlPgSetConfigRequest *PostgresqlPgSetConfigRequest
}

func (r ApiPostgresqlServiceSetConfigRequest) PostgresqlPgSetConfigRequest(postgresqlPgSetConfigRequest PostgresqlPgSetConfigRequest) ApiPostgresqlServiceSetConfigRequest {
	r.postgresqlPgSetConfigRequest = &postgresqlPgSetConfigRequest
	return r
}

func (r ApiPostgresqlServiceSetConfigRequest) Execute() (*PostgresqlPgSetConfigResponse, *http.Response, error) {
	return r.ApiService.PostgresqlServiceSetConfigExecute(r)
}

/*
PostgresqlServiceSetConfig Method for PostgresqlServiceSetConfig

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiPostgresqlServiceSetConfigRequest
*/
func (a *PostgresqlServiceApiService) PostgresqlServiceSetConfig(ctx context.Context, serviceId string) ApiPostgresqlServiceSetConfigRequest {
	return ApiPostgresqlServiceSetConfigRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return PostgresqlPgSetConfigResponse
func (a *PostgresqlServiceApiService) PostgresqlServiceSetConfigExecute(r ApiPostgresqlServiceSetConfigRequest) (*PostgresqlPgSetConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostgresqlPgSetConfigResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostgresqlServiceApiService.PostgresqlServiceSetConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/postgresql/{service_id}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postgresqlPgSetConfigRequest == nil {
		return localVarReturnValue, nil, reportError("postgresqlPgSetConfigRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postgresqlPgSetConfigRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostgresqlServiceUpdateDbRequest struct {
	ctx context.Context
	ApiService *PostgresqlServiceApiService
	serviceId string
	dbName string
	postgresqlPgUpdateDbRequest *PostgresqlPgUpdateDbRequest
}

func (r ApiPostgresqlServiceUpdateDbRequest) PostgresqlPgUpdateDbRequest(postgresqlPgUpdateDbRequest PostgresqlPgUpdateDbRequest) ApiPostgresqlServiceUpdateDbRequest {
	r.postgresqlPgUpdateDbRequest = &postgresqlPgUpdateDbRequest
	return r
}

func (r ApiPostgresqlServiceUpdateDbRequest) Execute() (*PostgresqlPgUpdateDbResponse, *http.Response, error) {
	return r.ApiService.PostgresqlServiceUpdateDbExecute(r)
}

/*
PostgresqlServiceUpdateDb Method for PostgresqlServiceUpdateDb

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @param dbName
 @return ApiPostgresqlServiceUpdateDbRequest
*/
func (a *PostgresqlServiceApiService) PostgresqlServiceUpdateDb(ctx context.Context, serviceId string, dbName string) ApiPostgresqlServiceUpdateDbRequest {
	return ApiPostgresqlServiceUpdateDbRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
		dbName: dbName,
	}
}

// Execute executes the request
//  @return PostgresqlPgUpdateDbResponse
func (a *PostgresqlServiceApiService) PostgresqlServiceUpdateDbExecute(r ApiPostgresqlServiceUpdateDbRequest) (*PostgresqlPgUpdateDbResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostgresqlPgUpdateDbResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostgresqlServiceApiService.PostgresqlServiceUpdateDb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/postgresql/{service_id}/db/{db_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"db_name"+"}", url.PathEscape(parameterToString(r.dbName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postgresqlPgUpdateDbRequest == nil {
		return localVarReturnValue, nil, reportError("postgresqlPgUpdateDbRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postgresqlPgUpdateDbRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostgresqlServiceUpdateRemoteAccessRequest struct {
	ctx context.Context
	ApiService *PostgresqlServiceApiService
	serviceId string
	postgresqlPgUpdateRemoteAccessRequest *PostgresqlPgUpdateRemoteAccessRequest
}

func (r ApiPostgresqlServiceUpdateRemoteAccessRequest) PostgresqlPgUpdateRemoteAccessRequest(postgresqlPgUpdateRemoteAccessRequest PostgresqlPgUpdateRemoteAccessRequest) ApiPostgresqlServiceUpdateRemoteAccessRequest {
	r.postgresqlPgUpdateRemoteAccessRequest = &postgresqlPgUpdateRemoteAccessRequest
	return r
}

func (r ApiPostgresqlServiceUpdateRemoteAccessRequest) Execute() (*PostgresqlPgUpdateRemoteAccessResponse, *http.Response, error) {
	return r.ApiService.PostgresqlServiceUpdateRemoteAccessExecute(r)
}

/*
PostgresqlServiceUpdateRemoteAccess Method for PostgresqlServiceUpdateRemoteAccess

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return ApiPostgresqlServiceUpdateRemoteAccessRequest
*/
func (a *PostgresqlServiceApiService) PostgresqlServiceUpdateRemoteAccess(ctx context.Context, serviceId string) ApiPostgresqlServiceUpdateRemoteAccessRequest {
	return ApiPostgresqlServiceUpdateRemoteAccessRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return PostgresqlPgUpdateRemoteAccessResponse
func (a *PostgresqlServiceApiService) PostgresqlServiceUpdateRemoteAccessExecute(r ApiPostgresqlServiceUpdateRemoteAccessRequest) (*PostgresqlPgUpdateRemoteAccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostgresqlPgUpdateRemoteAccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostgresqlServiceApiService.PostgresqlServiceUpdateRemoteAccess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/postgresql/{service_id}/remote-access"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postgresqlPgUpdateRemoteAccessRequest == nil {
		return localVarReturnValue, nil, reportError("postgresqlPgUpdateRemoteAccessRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postgresqlPgUpdateRemoteAccessRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostgresqlServiceUpdateRoleRequest struct {
	ctx context.Context
	ApiService *PostgresqlServiceApiService
	serviceId string
	roleName string
	postgresqlPgUpdateRoleRequest *PostgresqlPgUpdateRoleRequest
}

func (r ApiPostgresqlServiceUpdateRoleRequest) PostgresqlPgUpdateRoleRequest(postgresqlPgUpdateRoleRequest PostgresqlPgUpdateRoleRequest) ApiPostgresqlServiceUpdateRoleRequest {
	r.postgresqlPgUpdateRoleRequest = &postgresqlPgUpdateRoleRequest
	return r
}

func (r ApiPostgresqlServiceUpdateRoleRequest) Execute() (*PostgresqlPgUpdateRoleResponse, *http.Response, error) {
	return r.ApiService.PostgresqlServiceUpdateRoleExecute(r)
}

/*
PostgresqlServiceUpdateRole Method for PostgresqlServiceUpdateRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @param roleName
 @return ApiPostgresqlServiceUpdateRoleRequest
*/
func (a *PostgresqlServiceApiService) PostgresqlServiceUpdateRole(ctx context.Context, serviceId string, roleName string) ApiPostgresqlServiceUpdateRoleRequest {
	return ApiPostgresqlServiceUpdateRoleRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return PostgresqlPgUpdateRoleResponse
func (a *PostgresqlServiceApiService) PostgresqlServiceUpdateRoleExecute(r ApiPostgresqlServiceUpdateRoleRequest) (*PostgresqlPgUpdateRoleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostgresqlPgUpdateRoleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostgresqlServiceApiService.PostgresqlServiceUpdateRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloud/postgresql/{service_id}/role/{role_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role_name"+"}", url.PathEscape(parameterToString(r.roleName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postgresqlPgUpdateRoleRequest == nil {
		return localVarReturnValue, nil, reportError("postgresqlPgUpdateRoleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postgresqlPgUpdateRoleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
